本来想要把guess_number和easypt这两道当时费了很多时间，但是没有做出来的题目的writeup看懂，然后做出来的，但是看了很长时间，还是没有头绪。  
意识到，有些问题，不是靠坚持就能够解决的，还是需要有一定的知识积累。  
自己平时的积累确实太少了，所以决定放弃这两道题目，不再浪费时间。这两道题的writeup放在下面：
guess_number:
+ https://nars1st.tumblr.com/post/180614800257/guess-number-crypto-714
easypt:
+ https://xz.aliyun.com/t/3470#toc-7  
这个是我找到的最详细的writeup了
+ https://xz.aliyun.com/t/3465#toc-8
+ https://xz.aliyun.com/t/3472#toc-23  
后面两个writeup写得非常简略，仅做参考。

作为补偿，到ctf wiki上学习了**虚拟机指令分析**部分的知识点：
地址：https://ctf-wiki.github.io/ctf-wiki/reverse/vm/vm/#_6

程序其实就是一个简单的验证界面，输入用户名和密码，返回验证结果，这个和一般的reverse题目是一样的。  
这套题的特殊之处在于它对判断逻辑进行了隐藏，具体看下面程序的流程：
程序整体的流程：
1. 在process_input函数中发现用户名和密码都不能小于7位，满足这两个条件之后，就会对用户名进行简单的异或混淆操作。
2. 注册SEH函数，并且注册了好几个，通过构造除零异常触发SEH并执行，这里隐藏了真正的逻辑
3. 在真正的逻辑中，有一个实现了简单指令的虚拟机，这里对密码进行了判断

读懂了程序之后，按照他的过程根据密码生成密钥，其实就是用python还原程序的关键逻辑

tips：
1. 用C来转换成代码，用p来定义function
2. 在汇编代码的地方，按 '/' 可以将伪代码复制到汇编代码处
3. 分析程序，可以从程序可能调用的函数入手，来定位关键代码
4. 逆向的过程，就是一个不断分析，猜测程序功能的过程 

收获：
1. 获取了这类题目的基本思路，了解了这种隐藏逻辑的方法
2. 希望能够抽出时间来重头自己操作一遍，应该能够有更大的收获
